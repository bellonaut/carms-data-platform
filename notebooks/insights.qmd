---
title: "CaRMS Program Insights"
author: "Data Platform Team"
format:
  html:
    toc: true
    code-fold: true
    df-print: paged
execute:
  echo: false
  warning: false
  message: false
jupyter: python3
---

# Purpose
Lightweight analytical slices on the public CaRMS program data, matching the gold-layer use cases (geography rollups, discipline mix, description similarity). All code runs locally with the raw extracts; no database required.

# Data at a glance
- Source: CaRMS public program extract included in this repo (`data/1503_program_master.xlsx`) plus description sections (`1503_program_descriptions_x_section.csv` in the zip).
- Scope: 815 program streams across 37 disciplines and 18 schools; provinces derived via the same `derive_province` helper used in the pipeline (8 provinces observed).
- Stream meaning: entries are program streams (CMG, IMG, RoS, etc.), not seat counts. Use caution when inferring capacity.
- Cycle tag: “1503” corresponds to the extract shipped with this homework repo; no applicant outcomes are included.
- Missing pieces: no match/offer results, quotas, or applicant metadata, so insights focus on supply-side structure and text content.

# Setup
```python
import sys
from pathlib import Path

import numpy as np
import pandas as pd
import plotly.express as px
import torch
from sentence_transformers import SentenceTransformer

# add repo root to path so we can reuse parsing helpers
ROOT = Path(__file__).resolve().parents[1]
sys.path.append(str(ROOT))
DATA_DIR = ROOT / "data"

from carms.pipelines.silver.assets import derive_province  # reuse prod logic
```

# Province-level program density
```python
programs = pd.read_excel(DATA_DIR / "1503_program_master.xlsx").rename(columns=str.strip)
programs["province"] = programs.apply(
    lambda r: derive_province(r.program_site, r.school_name), axis=1
)
province_counts = (
    programs.groupby("province")
    .agg(programs=("program_stream_id", "count"))
    .reset_index()
    .sort_values("programs", ascending=False)
)

fig_province = px.bar(
    province_counts,
    x="province",
    y="programs",
    title="Programs per Province",
    labels={"programs": "Programs", "province": "Province"},
    color="programs",
    color_continuous_scale="Reds",
)
fig_province.update_layout(height=420)
fig_province
```

# Discipline mix
```python
discipline_counts = (
    programs.groupby("discipline_name")
    .agg(programs=("program_stream_id", "count"))
    .reset_index()
    .sort_values("programs", ascending=False)
    .head(15)
)

fig_disc = px.bar(
    discipline_counts,
    x="programs",
    y="discipline_name",
    orientation="h",
    title="Top Disciplines by Program Count",
    labels={"programs": "Programs", "discipline_name": "Discipline"},
    color="programs",
    color_continuous_scale="OrRd",
)
fig_disc.update_layout(height=520, yaxis=dict(autorange="reversed"))
fig_disc
```

# Quick reads (context for reviewers)
- Ontario and Quebec hold 56% of programs (315 + 142 of 815), so matching supply to applicant demand there matters most.
- Family Medicine is one-third of all programs (265 of 815); the top five disciplines cover 52% of seats, framing where national-scale changes would hit first.
- Province and discipline counts here reuse the same `derive_province` logic as the pipeline, so the map/API and this notebook stay consistent.
- The similarity heatmap below is a lightweight way to spot near-duplicate program descriptions before adding vector search or clustering.

# International Medical Graduate (IMG) lens
```python
programs = programs.copy()
programs["stream_type"] = np.where(
    programs["program_stream"].str.contains("IMG", case=False, na=False),
    "IMG",
    "Non-IMG",
)
img_only = programs.query("stream_type == 'IMG'")

img_stack = (
    programs.groupby(["province", "stream_type"])
    .agg(programs=("program_stream_id", "count"))
    .reset_index()
    .pivot(index="province", columns="stream_type", values="programs")
    .fillna(0)
    .reset_index()
)
img_stack["img_share"] = img_stack["IMG"] / (img_stack["IMG"] + img_stack["Non-IMG"])
img_stack = img_stack.sort_values("IMG", ascending=False)

fig_img = px.bar(
    img_stack,
    x="province",
    y=["IMG", "Non-IMG"],
    title="IMG vs other streams by province",
    labels={"value": "Programs", "province": "Province", "variable": "Stream"},
    color_discrete_map={"IMG": "#d62728", "Non-IMG": "#7f7f7f"},
)
fig_img.update_layout(barmode="stack", height=420, legend_title_text="Stream type")
fig_img
```

```python
share_img = len(img_only) / len(programs)
on_share = img_only.loc[img_only["province"] == "ON"].shape[0] / len(img_only)
top3_share = img_only.loc[img_only["province"].isin(["ON", "AB", "BC"])].shape[0] / len(
    img_only
)
family_share = (
    img_only.loc[img_only["discipline_name"] == "Family Medicine"].shape[0]
    / len(img_only)
)

print(
    f"""- IMG-labelled streams are {share_img:.1%} of all programs ({len(img_only)} of {len(programs)}).
- Ontario alone hosts {on_share:.1%} of IMG streams; ON+AB+BC together = {top3_share:.1%}, showing a tight geographic funnel.
- Family Medicine is {family_share:.1%} of IMG streams (81 programs), so IMG supply skews even harder to FM than the overall mix (~33%)."""
)
```

# Description similarity (SentenceTransformer + cosine heatmap)
```python
desc = pd.read_csv(DATA_DIR / "1503_program_descriptions_x_section.csv")
text_cols = [
    "program_contracts",
    "general_instructions",
    "supporting_documentation_information",
    "review_process",
    "interviews",
    "selection_criteria",
    "program_highlights",
    "program_curriculum",
    "training_sites",
    "additional_information",
    "return_of_service",
    "faq",
    "summary_of_changes",
]

# concatenate available text fields per program
desc["description_text"] = desc[text_cols].fillna("").agg("\n\n".join, axis=1)
sample = (
    desc[["program_description_id", "program_name", "description_text"]]
    .dropna(subset=["description_text"])
    .head(24)
)

torch.set_num_threads(1)
model = SentenceTransformer("all-MiniLM-L6-v2")
embeddings = model.encode(sample["description_text"].tolist(), normalize_embeddings=True)
similarity = np.matmul(embeddings, embeddings.T)

fig_sim = px.imshow(
    similarity,
    x=sample["program_name"],
    y=sample["program_name"],
    color_continuous_scale="Magma",
    title="Description Similarity (cosine)",
    labels=dict(color="cosine"),
)
fig_sim.update_layout(height=760)
fig_sim
```

# How to render
- HTML (recommended): `quarto render notebooks/insights.qmd --to html --output ../docs/insights.html`
- PDF (optional, needs LaTeX): `quarto render notebooks/insights.qmd --to pdf`
